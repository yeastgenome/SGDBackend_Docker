-- Generated by Ora2Pg, the Oracle database Schema converter, version 17.4
-- Copyright 2000-2016 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=sgd-nex2-db.stanford.edu;sid=SGD

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON


--
-- Checks to see if a chebiid exists in the CHEBI table
--
CREATE OR REPLACE FUNCTION checkchebi (p_chebi varchar) RETURNS VOID AS $body$
BEGIN

    IF NOT EXISTS (SELECT chebiid
                   FROM nex.chebi
	           WHERE chebiid = p_chebi)
    THEN
       RAISE EXCEPTION 'CHEBIID "%" does NOT exist in the CHEBI table.', p_chebi;
    END IF;

END;
$body$ LANGUAGE PLPGSQL
       SECURITY DEFINER
       SET search_path = nex, pg_temp;
GRANT EXECUTE on FUNCTION checkchebi (p_chebi varchar) to CURATOR;
REVOKE ALL ON FUNCTION checkchebi (p_chebi varchar) FROM PUBLIC;             


--
-- Checks to see if a particular Chemical name exists in the CHEBI table
--
CREATE OR REPLACE FUNCTION checkchemical (p_chemical varchar) RETURNS VOID AS $body$
BEGIN

    IF NOT EXISTS (SELECT display_name
                   FROM nex.chebi
	           WHERE display_name = p_chemical)
    THEN
       RAISE EXCEPTION 'CHEBI name "%" does NOT exist in the CHEBI table.', p_chemical;
    END IF;

END;
$body$ LANGUAGE PLPGSQL
       SECURITY DEFINER
       SET search_path = nex, pg_temp;
GRANT EXECUTE on FUNCTION checkchemical (p_chemical varchar) to CURATOR;
REVOKE ALL ON FUNCTION checkchemical (p_chemical varchar) FROM PUBLIC;


--
-- Checks to see if a phenotype:namespace exists in the APO table
--
CREATE OR REPLACE FUNCTION checkphenotype (p_phenotype bigint, p_namespace varchar) RETURNS VOID AS $body$
BEGIN

   IF NOT EXISTS (SELECT apo_id
                  FROM nex.apo
	          WHERE apo_id = p_phenotype
                  AND apo_namespace = lower(p_namespace))
   THEN
      RAISE EXCEPTION 'APO ID: % for NAMESPACE: % does NOT exist in the APO table.', p_phenotype, p_namespace;
   END IF;

END;
$body$ LANGUAGE PLPGSQL
       SECURITY DEFINER
       SET search_path = nex, pg_temp;
GRANT EXECUTE on FUNCTION checkphenotype (p_phenotype bigint, p_namespace varchar) to CURATOR;
REVOKE ALL ON FUNCTION checkphenotype (p_phenotype bigint, p_namespace varchar) FROM PUBLIC;         


--
-- Checks to see if a PMID exists in the referencedbentity table
-- If yes, prevents row from being inserted into REFERENCEDELETED table
--
CREATE OR REPLACE FUNCTION checkpubmed (p_pubmed bigint)  RETURNS VOID AS $body$
BEGIN

    IF EXISTS (SELECT pmid
               FROM nex.referencedbentity
               WHERE pmid = p_pubmed)
    THEN
       RAISE EXCEPTION 'PMID "%" exists in the REFERENCEDBENTITY table.', p_pubmed;
    END IF;

END;
$body$ LANGUAGE PLPGSQL
       SECURITY DEFINER
       SET search_path = nex, pg_temp;
GRANT EXECUTE on FUNCTION checkpubmed (p_pubmed bigint) to CURATOR;
REVOKE ALL ON FUNCTION checkpubmed (p_pubmed bigint) FROM PUBLIC;   


--
-- Checks to see if a SGDID exists in the sgdid table
--
CREATE OR REPLACE FUNCTION checksgdid (p_sgdid varchar)  RETURNS VOID AS $body$
BEGIN

    IF NOT EXISTS (SELECT display_name
                   FROM nex.sgdid
	           WHERE display_name = p_sgdid)
    THEN
       RAISE EXCEPTION 'SGDID "%" does NOT exists in the SGDID table.', p_sgdid;
    END IF;

END;
$body$ LANGUAGE PLPGSQL
       SECURITY DEFINER
       SET search_path = nex, pg_temp;
GRANT EXECUTE on FUNCTION checksgdid (p_sgdid varchar) to CURATOR;
REVOKE ALL ON FUNCTION checksgdid (p_sgdid varchar) FROM PUBLIC;


--
-- Checks to see if a username exists in the dbuser table
--
CREATE OR REPLACE FUNCTION checkuser(p_username varchar)  RETURNS VOID AS $$
BEGIN
    
    IF NOT EXISTS (SELECT username
                   FROM nex.dbuser
                   WHERE username = upper(p_username))
    THEN
          RAISE EXCEPTION 'Username "%" not found in dbuser table.', p_username;
    END IF;

END;
$$ LANGUAGE PLPGSQL
       SECURITY DEFINER
       SET search_path = nex, pg_temp;
GRANT EXECUTE on FUNCTION checkuser(p_username varchar) to CURATOR;
REVOKE ALL ON FUNCTION checkuser(p_username varchar) FROM PUBLIC;

